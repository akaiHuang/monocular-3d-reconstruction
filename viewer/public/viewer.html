<!DOCTYPE html>
<html lang="zh-TW">
    <head>
        <title>3D Gaussian Splats Viewer</title>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
        <style>
            * {
                margin: 0;
                padding: 0;
                box-sizing: border-box;
            }
            
            html, body {
                width: 100%;
                height: 100%;
                overflow: hidden;
                background: #1a1a2e;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            }
            
            #app {
                width: 100%;
                height: 100%;
            }
            
            #loading {
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
                z-index: 1000;
                transition: opacity 0.5s ease;
            }
            
            #loading.hidden {
                opacity: 0;
                pointer-events: none;
            }
            
            .spinner {
                width: 60px;
                height: 60px;
                border: 4px solid rgba(255, 255, 255, 0.1);
                border-top-color: #4f46e5;
                border-radius: 50%;
                animation: spin 1s linear infinite;
            }
            
            @keyframes spin {
                to { transform: rotate(360deg); }
            }
            
            #loading-text {
                margin-top: 20px;
                color: #e0e0e0;
                font-size: 16px;
            }
            
            #progress-bar {
                width: 200px;
                height: 6px;
                background: rgba(255, 255, 255, 0.1);
                border-radius: 3px;
                margin-top: 15px;
                overflow: hidden;
            }
            
            #progress-fill {
                width: 0%;
                height: 100%;
                background: linear-gradient(90deg, #4f46e5, #7c3aed);
                transition: width 0.3s ease;
            }
            
            #error {
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                display: none;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
                z-index: 1001;
                color: white;
                padding: 20px;
                text-align: center;
            }
            
            #error.show {
                display: flex;
            }
            
            #error h2 {
                color: #f87171;
                margin-bottom: 15px;
                font-size: 24px;
            }
            
            #error p {
                color: #9ca3af;
                max-width: 400px;
                line-height: 1.6;
            }
            
            #controls {
                position: fixed;
                bottom: 20px;
                left: 50%;
                transform: translateX(-50%);
                display: flex;
                gap: 10px;
                padding: 10px 15px;
                background: rgba(0, 0, 0, 0.7);
                backdrop-filter: blur(10px);
                border-radius: 12px;
                z-index: 100;
            }
            
            #controls button {
                background: rgba(255, 255, 255, 0.1);
                border: 1px solid rgba(255, 255, 255, 0.2);
                color: white;
                padding: 8px 16px;
                border-radius: 8px;
                cursor: pointer;
                font-size: 14px;
                transition: all 0.2s;
            }
            
            #controls button:hover {
                background: rgba(255, 255, 255, 0.2);
            }
            
            #controls button.active {
                background: #4f46e5;
                border-color: #4f46e5;
            }
            
            #info {
                position: fixed;
                top: 15px;
                left: 15px;
                color: white;
                font-size: 12px;
                background: rgba(0, 0, 0, 0.5);
                padding: 8px 12px;
                border-radius: 8px;
                z-index: 100;
            }
            
            canvas {
                width: 100% !important;
                height: 100% !important;
            }
        </style>
    </head>
    <body>
        <div id="app"></div>
        
        <div id="loading">
            <div class="spinner"></div>
            <div id="loading-text">載入中...</div>
            <div id="progress-bar">
                <div id="progress-fill"></div>
            </div>
        </div>
        
        <div id="error">
            <h2>⚠️ 載入失敗</h2>
            <p id="error-message">無法載入 3D 模型</p>
        </div>
        
        <div id="info"></div>
        
        <div id="controls">
            <button id="btn-orbit" class="active">環繞模式</button>
            <button id="btn-fly">自由飛行</button>
            <button id="btn-reset">重置視角</button>
        </div>

        <script type="module">
            import * as pc from 'https://cdn.jsdelivr.net/npm/playcanvas@2.4.0/build/playcanvas.mjs';
            
            // 取得 URL 參數
            const urlParams = new URLSearchParams(window.location.search);
            const plyUrl = urlParams.get('ply') || urlParams.get('content');
            
            const loadingEl = document.getElementById('loading');
            const loadingText = document.getElementById('loading-text');
            const progressFill = document.getElementById('progress-fill');
            const errorEl = document.getElementById('error');
            const errorMessage = document.getElementById('error-message');
            const infoEl = document.getElementById('info');
            
            function showError(msg) {
                errorMessage.textContent = msg;
                errorEl.classList.add('show');
                loadingEl.classList.add('hidden');
            }
            
            function updateProgress(percent, text) {
                progressFill.style.width = percent + '%';
                if (text) loadingText.textContent = text;
            }
            
            if (!plyUrl) {
                showError('請在 URL 中提供 PLY 檔案路徑，例如: ?ply=/api/ply/xxx/file.ply');
            } else {
                initViewer();
            }
            
            async function initViewer() {
                try {
                    updateProgress(10, '初始化引擎...');
                    
                    const canvas = document.createElement('canvas');
                    canvas.id = 'viewer-canvas';
                    document.getElementById('app').appendChild(canvas);
                    
                    // 創建 PlayCanvas 應用
                    const app = new pc.Application(canvas, {
                        graphicsDeviceOptions: {
                            preferWebGl2: true,
                            antialias: true,
                            preserveDrawingBuffer: true,
                            powerPreference: 'high-performance'
                        }
                    });
                    
                    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);
                    app.setCanvasResolution(pc.RESOLUTION_AUTO);
                    
                    // 創建場景
                    updateProgress(20, '設置場景...');
                    
                    // 創建相機
                    const camera = new pc.Entity('camera');
                    camera.addComponent('camera', {
                        clearColor: new pc.Color(0.1, 0.1, 0.12),
                        farClip: 1000,
                        nearClip: 0.01,
                        fov: 60
                    });
                    camera.setPosition(0, 1, 3);
                    camera.lookAt(0, 0, 0);
                    app.root.addChild(camera);
                    
                    // 創建軌道控制
                    let orbitMode = true;
                    let orbitRadius = 3;
                    let orbitTheta = 0;
                    let orbitPhi = Math.PI / 4;
                    let targetPoint = new pc.Vec3(0, 0, 0);
                    let isDragging = false;
                    let lastMouseX = 0;
                    let lastMouseY = 0;
                    
                    // 滑鼠控制
                    canvas.addEventListener('mousedown', (e) => {
                        isDragging = true;
                        lastMouseX = e.clientX;
                        lastMouseY = e.clientY;
                    });
                    
                    canvas.addEventListener('mouseup', () => {
                        isDragging = false;
                    });
                    
                    canvas.addEventListener('mousemove', (e) => {
                        if (!isDragging) return;
                        
                        const deltaX = e.clientX - lastMouseX;
                        const deltaY = e.clientY - lastMouseY;
                        lastMouseX = e.clientX;
                        lastMouseY = e.clientY;
                        
                        if (orbitMode) {
                            orbitTheta += deltaX * 0.01;
                            orbitPhi = Math.max(0.1, Math.min(Math.PI - 0.1, orbitPhi + deltaY * 0.01));
                        } else {
                            // 自由飛行模式
                            const rotation = camera.getEulerAngles();
                            camera.setEulerAngles(
                                rotation.x - deltaY * 0.2,
                                rotation.y - deltaX * 0.2,
                                rotation.z
                            );
                        }
                    });
                    
                    canvas.addEventListener('wheel', (e) => {
                        e.preventDefault();
                        if (orbitMode) {
                            orbitRadius = Math.max(0.5, Math.min(20, orbitRadius + e.deltaY * 0.01));
                        } else {
                            // 自由飛行模式下的前後移動
                            const forward = camera.forward.clone();
                            camera.translate(forward.mulScalar(-e.deltaY * 0.01));
                        }
                    });
                    
                    // 觸控支援
                    let touchStartDistance = 0;
                    canvas.addEventListener('touchstart', (e) => {
                        if (e.touches.length === 1) {
                            isDragging = true;
                            lastMouseX = e.touches[0].clientX;
                            lastMouseY = e.touches[0].clientY;
                        } else if (e.touches.length === 2) {
                            const dx = e.touches[0].clientX - e.touches[1].clientX;
                            const dy = e.touches[0].clientY - e.touches[1].clientY;
                            touchStartDistance = Math.sqrt(dx * dx + dy * dy);
                        }
                    });
                    
                    canvas.addEventListener('touchmove', (e) => {
                        e.preventDefault();
                        if (e.touches.length === 1 && isDragging) {
                            const deltaX = e.touches[0].clientX - lastMouseX;
                            const deltaY = e.touches[0].clientY - lastMouseY;
                            lastMouseX = e.touches[0].clientX;
                            lastMouseY = e.touches[0].clientY;
                            
                            orbitTheta += deltaX * 0.01;
                            orbitPhi = Math.max(0.1, Math.min(Math.PI - 0.1, orbitPhi + deltaY * 0.01));
                        } else if (e.touches.length === 2) {
                            const dx = e.touches[0].clientX - e.touches[1].clientX;
                            const dy = e.touches[0].clientY - e.touches[1].clientY;
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            const scale = touchStartDistance / distance;
                            orbitRadius = Math.max(0.5, Math.min(20, orbitRadius * scale));
                            touchStartDistance = distance;
                        }
                    });
                    
                    canvas.addEventListener('touchend', () => {
                        isDragging = false;
                    });
                    
                    // 按鈕控制
                    document.getElementById('btn-orbit').addEventListener('click', () => {
                        orbitMode = true;
                        document.getElementById('btn-orbit').classList.add('active');
                        document.getElementById('btn-fly').classList.remove('active');
                    });
                    
                    document.getElementById('btn-fly').addEventListener('click', () => {
                        orbitMode = false;
                        document.getElementById('btn-fly').classList.add('active');
                        document.getElementById('btn-orbit').classList.remove('active');
                    });
                    
                    document.getElementById('btn-reset').addEventListener('click', () => {
                        orbitRadius = 3;
                        orbitTheta = 0;
                        orbitPhi = Math.PI / 4;
                        targetPoint.set(0, 0, 0);
                        camera.setPosition(0, 1, 3);
                        camera.lookAt(0, 0, 0);
                    });
                    
                    // 啟動應用
                    app.start();
                    
                    // 更新相機位置
                    app.on('update', () => {
                        if (orbitMode) {
                            const x = orbitRadius * Math.sin(orbitPhi) * Math.sin(orbitTheta);
                            const y = orbitRadius * Math.cos(orbitPhi);
                            const z = orbitRadius * Math.sin(orbitPhi) * Math.cos(orbitTheta);
                            camera.setPosition(x + targetPoint.x, y + targetPoint.y, z + targetPoint.z);
                            camera.lookAt(targetPoint);
                        }
                    });
                    
                    // 載入 PLY
                    updateProgress(30, '下載 PLY 檔案...');
                    
                    const response = await fetch(plyUrl);
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    
                    const contentLength = response.headers.get('content-length');
                    const total = contentLength ? parseInt(contentLength, 10) : 0;
                    
                    const reader = response.body.getReader();
                    const chunks = [];
                    let loaded = 0;
                    
                    while (true) {
                        const { done, value } = await reader.read();
                        if (done) break;
                        chunks.push(value);
                        loaded += value.length;
                        if (total > 0) {
                            const percent = 30 + Math.round((loaded / total) * 50);
                            updateProgress(percent, `下載中... ${Math.round(loaded / 1024 / 1024 * 10) / 10} MB`);
                        }
                    }
                    
                    updateProgress(80, '解析 PLY 數據...');
                    
                    const blob = new Blob(chunks);
                    const arrayBuffer = await blob.arrayBuffer();
                    
                    // 解析 PLY header
                    const text = new TextDecoder().decode(arrayBuffer.slice(0, 2000));
                    const headerEnd = text.indexOf('end_header');
                    
                    if (headerEnd === -1) {
                        throw new Error('無效的 PLY 檔案格式');
                    }
                    
                    const header = text.slice(0, headerEnd);
                    const vertexMatch = header.match(/element vertex (\d+)/);
                    const vertexCount = vertexMatch ? parseInt(vertexMatch[1], 10) : 0;
                    
                    updateProgress(90, `處理 ${vertexCount.toLocaleString()} 個點...`);
                    
                    // 由於 PlayCanvas 需要特殊的 GSplat 擴展來渲染 Gaussian Splats
                    // 這裡我們先顯示基本的點雲
                    
                    // 解析二進制數據 - 簡化版本，只取位置和顏色
                    const headerLength = headerEnd + 'end_header\n'.length;
                    const dataView = new DataView(arrayBuffer, headerLength);
                    
                    // PLY 格式: x, y, z, f_dc_0, f_dc_1, f_dc_2, opacity, scale_0, scale_1, scale_2, rot_0-3
                    // 每個頂點 14 個 float (56 bytes)
                    const positions = new Float32Array(vertexCount * 3);
                    const colors = new Float32Array(vertexCount * 4);
                    
                    const bytesPerVertex = 14 * 4; // 14 floats
                    
                    for (let i = 0; i < Math.min(vertexCount, 500000); i++) { // 限制顯示數量
                        const offset = i * bytesPerVertex;
                        
                        // 位置
                        positions[i * 3] = dataView.getFloat32(offset, true);
                        positions[i * 3 + 1] = dataView.getFloat32(offset + 4, true);
                        positions[i * 3 + 2] = dataView.getFloat32(offset + 8, true);
                        
                        // 顏色 (f_dc_0, f_dc_1, f_dc_2 是 spherical harmonics)
                        // 轉換公式: color = 0.5 + C0 * sh_dc
                        const C0 = 0.28209479177387814;
                        const r = 0.5 + C0 * dataView.getFloat32(offset + 12, true);
                        const g = 0.5 + C0 * dataView.getFloat32(offset + 16, true);
                        const b = 0.5 + C0 * dataView.getFloat32(offset + 20, true);
                        const opacity = 1 / (1 + Math.exp(-dataView.getFloat32(offset + 24, true)));
                        
                        colors[i * 4] = Math.max(0, Math.min(1, r));
                        colors[i * 4 + 1] = Math.max(0, Math.min(1, g));
                        colors[i * 4 + 2] = Math.max(0, Math.min(1, b));
                        colors[i * 4 + 3] = opacity;
                    }
                    
                    // 計算場景中心和大小
                    let minX = Infinity, maxX = -Infinity;
                    let minY = Infinity, maxY = -Infinity;
                    let minZ = Infinity, maxZ = -Infinity;
                    
                    for (let i = 0; i < positions.length; i += 3) {
                        minX = Math.min(minX, positions[i]);
                        maxX = Math.max(maxX, positions[i]);
                        minY = Math.min(minY, positions[i + 1]);
                        maxY = Math.max(maxY, positions[i + 1]);
                        minZ = Math.min(minZ, positions[i + 2]);
                        maxZ = Math.max(maxZ, positions[i + 2]);
                    }
                    
                    const centerX = (minX + maxX) / 2;
                    const centerY = (minY + maxY) / 2;
                    const centerZ = (minZ + maxZ) / 2;
                    const size = Math.max(maxX - minX, maxY - minY, maxZ - minZ);
                    
                    // 正規化位置
                    for (let i = 0; i < positions.length; i += 3) {
                        positions[i] = (positions[i] - centerX) / size * 2;
                        positions[i + 1] = (positions[i + 1] - centerY) / size * 2;
                        positions[i + 2] = (positions[i + 2] - centerZ) / size * 2;
                    }
                    
                    // 創建點雲
                    const mesh = new pc.Mesh(app.graphicsDevice);
                    mesh.setPositions(positions);
                    mesh.setColors32(new Uint8Array(colors.map(c => Math.round(c * 255))));
                    mesh.update(pc.PRIMITIVE_POINTS);
                    
                    // 創建材質
                    const material = new pc.StandardMaterial();
                    material.useLighting = false;
                    material.diffuseVertexColor = true;
                    material.cull = pc.CULLFACE_NONE;
                    material.blendType = pc.BLEND_NORMAL;
                    material.update();
                    
                    // 創建網格實例
                    const meshInstance = new pc.MeshInstance(mesh, material);
                    
                    // 創建實體
                    const entity = new pc.Entity('splat');
                    entity.addComponent('render', {
                        meshInstances: [meshInstance],
                        type: 'asset'
                    });
                    // 翻轉以符合 SHARP 的座標系統 (OpenCV: y down, z forward)
                    entity.setEulerAngles(180, 0, 0);
                    app.root.addChild(entity);
                    
                    updateProgress(100, '載入完成！');
                    
                    // 更新資訊
                    infoEl.textContent = `${vertexCount.toLocaleString()} 個 Gaussian Splats`;
                    
                    setTimeout(() => {
                        loadingEl.classList.add('hidden');
                    }, 500);
                    
                } catch (err) {
                    console.error('Viewer 錯誤:', err);
                    showError(err.message || '載入失敗');
                }
            }
        </script>
    </body>
</html>
